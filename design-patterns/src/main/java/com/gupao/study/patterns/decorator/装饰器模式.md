##装饰器模式
装饰者模式（DecoratorPattern）是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能），属于结构型模式。

#应用场景
如果需要在不影响其它对象的情况下，以动态、透明的方式给对象添加职责，可以使用装饰模式，这几乎就是装饰模式的主要功能

如果不合适使用子类来进行扩展的时候，可以考虑使用装饰模式，因为装饰模式是使用的“对象组合”的方式。所谓不适合用子类扩展的方式，比如：扩展功能需要的子类太多，造成子类数目呈爆炸性增长。

#装饰者模式的优缺点
优点：

装饰者是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。

通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果。

装饰者完全遵守开闭原则。

#缺点：

会出现更多的代码，更多的类，增加程序复杂性。

动态装饰时，多层装饰时会更复杂。

装饰者模式和适配器模式
适配器模式能模拟实现简单的装饰模式的功能，也就是为已有功能增添功能，比如

public void adapterMethod(){
    System.out.println("在调用Adaptee的方法之前完成一定的工作");
    //调用Adaptee的相关方法
    adaptee.method();
    System.out.println("在调用Adaptee的方法之后完成一定的工作");
}
因为两种设计模式在实现上都是使用的对象组合，都可以在转调组合对象的功能前后进行一些附加的处理，所以有这么一个相似性。

但两个模式有一个很大的不同：一般适配器适配过后是需要改变接口的，如果不改接口就没有必要适配了；而装饰模式是不改接口的，无论多少层装饰都是一个接口。因此装饰模式可以很容易的支持递归组合，而适配器就做不到了，每次的接口不同，没法递归。

装饰模式的本质：动态组合
动态是手段，组合才是目的。这里的组合有两个意思，一个是动态功能的组合，也就是动态进行装饰器的组合；另外一个是指对象组合，通过对象组合来实现为被装饰对象透明的增加功能。

但是要注意，装饰模式不仅仅可以增加功能，也可以控制功能的访问，可以完全实现新的功能，还可以控制装饰的功能是在被装饰功能之前还是之后来运行等。

总之，装饰模式是通过把复杂功能简单化，分散化，然后在运行期间，根据需要来动态组合的这么一个模式。